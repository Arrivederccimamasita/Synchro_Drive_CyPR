\documentclass[a4paper,twoside]{article}

%% Language and font encodings
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=0.5cm]{geometry}

\usepackage{amsmath}			%Paquete matemático
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}

\usepackage{hyperref}		%Paquete empleado para colocar hipervinculos
\hypersetup{
	colorlinks = true,
	linkcolor = black,
}

\usepackage{eurosym}
\usepackage{pdfpages}			%Sirve para incluir PDF en el documento
\usepackage{anysize}			%Podremos colocar imagenes de cualquier tamaño
\usepackage{subfig}				%Nos permitira colocar varias imagenes en una figura
\usepackage{float}				%Podremos crear y colocar boxes donee queramos
\usepackage[export]{adjustbox}

%Colocamos cabeceras y pies de pagina
%(CONSULTA: http://edicionesoniricas.com/maquetar-latex-encabezados-pies-pagina/)
%(CONSULTA2: https://es.sharelatex.com/learn/Headers_and_footers)
%\bfseries es análogo a \textbf{}
% \leftmark-> Adds name and number of the current top-level structure (section for article) in uppercase letters.
%\rightmark-> Adds name and number of the current next to top-level structure (subsection for article) in uppercase letters.
\usepackage{fancyhdr}		%Paquetes necesarios
\pagestyle{fancy}			%Borra los parametros por defecto
\fancyhf{}
\fancyhead[RO,LE]{\bfseries\thepage}
\fancyhead[LO,RE]{\bfseries\rightmark}
%Nos aseguramos de que en las paginas plain, no haya ni cabeceras ni lineas
\fancypagestyle{plain}
{
	\fancyhead{} % elimina cabeceras en paginas "plain"
	\renewcommand{\headrulewidth}{0pt} % así como la raya
}

%Definimos las lineas divisoras de las cabeceras y pie de pagina
\renewcommand{\headrulewidth}{1pt}	%Define el grosor de la línea de head
\renewcommand{\footrulewidth}{0pt}		%Define el grosor de la linea foot (Si no queremos linea, 0pt)
\addtolength{\headheight}{0.5pt} % espacio para la raya

%Librerias para introducir código de Matlab
%\usepackage{bigfoot} % to allow verbatim in footnote
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{listings,lstautogobble}
\lstset{
	style              = Matlab-editor,
	basicstyle         = \mlttfamily,
	escapechar         = ",
	mlshowsectionrules = true,
	autogobble=true
	language=Matlab
}

% Pie de pagina
%\fancyfoot{} % limpia el pie
\fancyfoot[C]{- \thepage -} % número de página centrado

%Nos generará texto para pruebas de maquetado
\usepackage{lipsum}

% Se varia el limite de colimnas de latex
\setcounter{MaxMatrixCols}{11}
\usepackage{lscape}
%----------------------------------------------------------------------------------------------------------------------------------
\begin{document}
\begin{titlepage}
	\centering
\Huge{\textbf{CONTROL Y PROGRAMACIÓN DE ROBOTS}} \\
\Huge{\textit{Proyecto de robótica móvil}}\\

\vspace{1cm}
\LARGE{Grado en Ingeniería Electrónica, Mecatrónica y Robótica}\\
\rule{\textwidth}{0.1mm}
%  %%%%% Este trozo de codigo es para insertar imagenes %%%%%%%
\begin{figure}[h!]
	\centering
	\includegraphics[width=.7\textwidth]{robot_portada}
	%\caption{textodelaleyenda}
\end{figure}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1cm}
\rule{\textwidth}{0.1mm}
\Large{\textbf{Autores:} Montes Grova, Marco Antonio\\
 Lozano Romero, Daniel\\
 Mérida Floriano, Javier}
\end{titlepage}
\tableofcontents
\newpage
% %%%%%%%%%%%   INTRODUCCION %%%%%%%%%%%%%%%%%%
\section{Introducción al proyecto}
En el proyecto que sigue a continuación se desarrollará el modelado y control de un robot móvil tipo síncrono. La principal característica destacable de este tipo de robots recae en el mecanismo mecánico interno que posee mediante el cuál se podrán mover 3 ruedas empleando únicamente 2 motores.\\
Con uno de los motores se desplazará en línea recta y con el otro se le dará el ángulo de giro deseado sobre sí mismo.\\

El modelo síncrono se basa en 3 ruedas idénticas que se desplazan y giran al unísono, haciendo posible que el robot pueda moverse en cualquier dirección y orientación en el plano del suelo. Estas ruedas están dispuestas de forma triangular en la base del robot, el cual se va a representar como un objeto cilíndrico, siendo la base uno de los lados circulares. Par un mayor entendimiento, se va a representar un esquema del mecanismo utilizado en este tipo de robot móvil:\\

\begin{figure}[h!]
	\centering
	\includegraphics[width=.6\textwidth]{mecanismo_interno}
\end{figure}

Este modelo tiene como ventajas la separación de motores entre traslación y rotación que facilita el control, la garantía de control en trayectorias rectilíneas debido a la mecánica del mismo y la facilidad que incluyen las restricciones homólogas que posee. Como desventaja encontramos el complejo diseño mecánico que posee para poder transmitir la rotación y traslación a las tres ruedas simultáneamente y, por ende, su difícil implementación en la realidad.\\
% SEGUIR HABLANDO DE MOVIDAS TEORICAS UN PSEUDO LARGO TRECHO ETC ETC ETC ETC

\section{Análisis cinemático}
	\subsection{Introducción teórica y simplificación del modelo}
	Gracias a la mecánica del modelo síncrono, los cálculos para la obtención del modelo cinemático del mismo van a ser sencillos, ya que se trata de un modelo con restricciones holónomas, es decir, el comportamiento del vehículo se puede representar a través de sus variables generalizadas:
	\begin{itemize}
		\item Las variables cartesianas \textit{X} y \textit{Y} como coordenadas del centro del robot en el plano del suelo.
		\item La variable angular $\varphi$ como la rotación producida frente al estado inicial, es decir, cuando éste vale cero.
	\end{itemize}
	las cuales son integrables en el tiempo de tal modo que resulta sencillo la obtención de un modelo cinemático de posiciones y velocidades.\\
	La postura del robot, se podría obtener a partir de la aplicación de una matriz de rotación en torno al eje perpendicular al plano de suelo, es decir, respecto al eje Z:
	\begin{equation}
		R(\varphi)=
		\begin{bmatrix}
			cos\varphi & sin\varphi & 0 \\
			-sin\varphi & cos\varphi & 0 \\
			0 & 0 & 1
		\end{bmatrix}
	\end{equation}
	Además de ello, cabe destacar que, para simplificar el modelado del robot, se han asumido una serie de restricciones cinemáticas en las ruedas cómo son:
	\begin{itemize}
		\item Movimiento en un plano horizontal.
		\item Las ruedas poseen un único punto de contacto.
		\item Las ruedas no son deformables.
		\item $v_c$ en el punto de contacto será nulo.
		\item La rueda no resbala, sino que produce un movimiento de arraste o deslizamiento.
		\item No habrá fricción en el punto de contecto.
		\item Los ejes de dirección serán en todo momento ortogonales a la superficie.
		\item Las ruedas están conectadas al bastidor de giro.
	\end{itemize}

\subsection{Obtención del modelo cinemático directo y su Jacobiano}
Para el modelo cinemático directo en cuestión, sólo se necesita como dato el valor del radio de las ruedas, $R$, para poder realizar la conversión entre velocidad angular y velocidad lineal. En este trabajo, siendo el grupo de trabajo número 11, se tiene cómo radio de las ruedas el valor de $R = 0.4 m$. Con esto ya se puede hallar el modelo cinemático del robot:\\

	Para comenzar se deben definir las variables generalizadas y de actuación del sistema, respectivamente:
	\begin{center}
		$
		q=
		\begin{bmatrix}
		x\\
		y\\
		\varphi
		\end{bmatrix}
		$$
		\hspace{2cm}
		$$
		p=
		\begin{bmatrix}
		\dot{\theta} \\
		\omega
		\end{bmatrix}
		$
\end{center}

Como ya vio en las clases de la asignatura, las variables generalizadas son las que dan información sobre el estado del robot, ya que se encuentran en ellas las coordenadas cartesianas \textit{X} e \textit{Y} del plano del centro del robot y el ángulo de giro $\varphi$ con respecto al eje X, como se ha decidido definir en este proyecto.\\
Así mismo, las variables de actuación son, como dice su nombre, las variables que reflejarán el valor de movimiento de los motores del robot, es decir, del motor encargado del desplazamiento (velocidad angular de desplazamiento, $\dot{\theta}$) y del encargado de la rotación (velocidad angular de rotación, $\omega$).\\

Una vez detectadas las variables del sistema, se deberá definir la relación entre ellas y, de ese modo,obtener la expresión del Jacobiano, es decir, la relación entre la derivada de las variables articulares de salida y de entrada.\\
En primer lugar, se definirá $v$ como la componente global de velocidad de desplazamiento, por tanto, se calculará como:
\begin{center}
	$v^2=\dot{x}^2+\dot{y}^2$ o como $v=R \dot{\theta}$
	\end{center}
	y, a su vez, la componentes cartesianas de la velocidad se definirán como:
	\begin{center}
	$\dot{x}=v cos(\varphi)$\\
	$\dot{y}=v sin(\varphi)$
	\end{center}


	Sabiendo además que la velocidad de rotación $\dot{\varphi}$ concuerda con la variable de actuación $\omega$, se puede montar la matriz Jacobiana del sistema del mismo que se dijo anteriormmente, es decir:
\begin{center}
		$
		J=
		\begin{bmatrix}
			R cos(\varphi) && 0\\
			R sin(\varphi) && 0\\
			0 && 1
		\end{bmatrix}
		$
\end{center}

La matriz Jacobiana describirá la cinemática directa del sistema relacionando las variables de actuación con las derivadas de las variables generalizadas y, como se sabe que serán integrables debido a la existencia de restricciones holónomas, se podrán integrar para poder hallar los valores de posición y orientación.\\

	Dicho esto, se puede expresar el modelo cinemático como función de entradas (variables de actuación) y salidas (variables generalizadas):
	\begin{equation}
		\begin{bmatrix}
		\dot{x}\\
		\dot{y}\\
		\dot{\varphi}
		\end{bmatrix}
		=
		\begin{bmatrix}
		R cos(\varphi) && 0\\
		R sin(\varphi) && 0\\
		0 && 1
		\end{bmatrix}
		\begin{bmatrix}
		\dot{\theta}\\
		\omega
		\end{bmatrix}
	\end{equation}

	e integrando respecto del tiempo éstas matrice,se obtendrá:
		\begin{equation}
		\begin{bmatrix}
		x\\
		y\\
		\varphi
		\end{bmatrix}
		=
		\begin{bmatrix}
		x_0\\
		y_0\\
		\varphi_0
		\end{bmatrix}
		+
		\begin{bmatrix}
		\int_{0}^{t} R\dot{\theta}cos(\varphi)dt\\
		\int_{0}^{t} R\dot{\theta}sin(\varphi)dt\\
		\int_{0}^{t} \omega dt
		\end{bmatrix}
	\end{equation}

	dónde $x_0$, $y_0$ y $\varphi_0$ serán las condiciones iniciales de posición y orientación.\\
	\subsubsection{Esquema de simulación del modelo directo obtenido}
	Una vez obtenido el modelo cinemático directo se implementará en una función en Matlab, la cuál servida para modelar el comportamiento del movimiento del robot. Por tanto, el modelo cinematico directo se implementará del siguiente modo:
	% AQUI VA EL CODIGO DE PRUEBAS MCD -> METIDO EN UN ANEXO
	\lstinputlisting[caption = {Implementación del modelo cinemático directo}]{MCD_movil.m}

	A continuación, se mostrará el montaje completo en Simulink que ha sido utilizado para obtener los resultados de la simulación.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=.8\textwidth]{simulink_MCD_1}
		\caption{Esquema global}
	\end{figure}

En éste montaje existen dos subsistemas, los cuales se mostrarán a continuación. El primero de ellos, será el encargado de generar una actuación senoidal sobre el sobor, de tal modo que siga una trayectoria de éste tipo.
\begin{figure}[h!]
	\centering
	\includegraphics[width=.5\textwidth]{simulink_MCD_2}
	\caption{Esquema del bloque \textit{Actuación Senoidal}}
\end{figure}

 El segundo de ellos, será la implmentación del modelo cinemático directo del robot en un bloque, en el cuál se relamientará la variable angular, la cual es una variable de entrada y de salida del modelo y, además de ello, se saturarán las actuaciones.
 \begin{figure}[h!]
	 \centering
	 \includegraphics[width=.65\textwidth]{simulink_MCD_3}
	 \caption{Esquema del bloque \textit{DCM Synchro-Drive}}
 \end{figure}

\newpage
Cabe destacar cómo se saturarán las variables del modelo; la velocidad angular, se limitará a aproximadamente $\pm$ 15 grados por segundo, ya que es el angulo máximo aproximado al que teóricamente se puede girar un volante. En cuando a la velocidad lineal, se limitará aproximadamente a 30 centímetros por segundo, que correspondería aproximadamente a 1 km/h, lo cuál se considera una velocidad suficiente para un robot móvil.\\

Antes de introducir los experimentos realizados, cabe destacar que en un anexo se encontrarán los códigos de programación implementados para realizar dichos experimentos.

\subsubsection{Experimentos realizados al modelo para su verificación}
Con este código se pueden realizar varios experimentos. Para todos ellos las características comunes serán que partirán de las mismas condiciones iniciales para las variables generalizadas ($x=0, y=0, \varphi=0$) y tendrán las mismas saturaciones, las cuales hemos supuesto como realistas para este tipo de robot.\\
	\begin{itemize}

		\item \textbf{Primer experimento} \\
	El primer experimento que se va a mostrar es el de una velocidad de desplazamiento máxima y velocidad de rotación nula. Como la simulación dura 30 segundos, el robot deberá recorrer una distancia de 9 metros:

	\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{exp_MCD_1}
		\caption{Movimiento en el plano con actuación de desplazamiento constante y rotativa nula}
	\end{figure}

\newpage
	\item \textbf{Segundo experimento} \\
	El siguiente experimento combinará ambas variables de actuación, estableciendo el valor máximo en ambas, por lo que el robot deberá dar vueltas en círculo. Como la velocidad de rotación máxima es de 15 grados/segundo y la simulación dura 30 segundos, el robot deberá dar 1 vuelta y 1/4 de vuelta más. En este y el siguiente experimento, al no constar únicamente de una trayectoria rectilínea, se ha aprovechado para representar, a través de flechas, el vector velocidad de desplazamiento:

	\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{exp_MCD_2}
		\caption{Movimiento en el plano con actuación de desplazamiento y rotativa constantes}
	\end{figure}

	\item \textbf{Tercer experimento} \\
	Ahora se va a realizar el experimento correspondiente a la prueba solicitada para el trabajo donde se ha de suministrar una velocidad de desplazamiento constante y una velocidad de rotación con carácter senoidal. Para ello, se ha introducido una velocidad de desplazamiento de 0.5 radianes/segundo y una senoide de 0.05 Hz de frecuencia y 0.2 radianes/segundo de amplitud:
	\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{exp_MCD_3_1}
		\caption{Movimiento en el plano con actuación rotativa senoidal}
		\label{exp_MCD_3_1}
	\end{figure}

	En este último experimento se puede observar que la variable de actuación $\omega$ resulta la senoide esperada y que, como resultado, se obtiene también una trayectoria senoidal, cómo se observa en la figura número \ref{exp_MCD_3_1}.\\

	\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{exp_MCD_3_2}
		\caption{Variables de actuación tras saturación (arriba $\dot{\theta}$ y abajo $\omega$)}
		\label{exp_MCD_3_2}
	\end{figure}
	\end{itemize}

\newpage
	\subsection{Obtención del modelo cinemático inverso}
Una vez comentado todo lo que concierne a la cinemática directa, se puede pasar a obtener el modelo cinemático inverso, el cual será de utilidad para la creación de trayectorias con las variables generalizadas y su posterior transformación a variables de actuación que harán que el robot siga dicha trayectoria.\\

Dicho esto, el modelo cinemático inverso se basa principalmente en la Jacobiana inversa, ya que ahora se desea relacionar las variables generalizadas como entradas con las variables de actuación como salida. Por ello únicamente hay que coger la ecuación del modelo cinemático directo y pasar el Jacobiano al otro lado, es decir, poner su inversa. \\

En este caso se da que el Jacobiano del modelo directo no es una matriz cuadrada, por lo que no puede tener inversa, así que habrá que realizar la pseudoinversa del mismo. Para ello, no es necesario realizar los cálculos paso por paso, ya que MATLAB posee una función que calcula la pseudoinversa por el método Moore-Penrose llamada $pinv$. Dicho esto, una vez utilizada la función y habiendo simplificado, el resultado es:
\begin{equation}
	J^{-1}=
	\begin{bmatrix}
	\dfrac{cos(\varphi)}{R} && \dfrac{sin(\varphi)}{R} && 0\\
	0 && 0 && 1
	\end{bmatrix}
\end{equation}


Una vez obtenida la expresión del Jacobiano inverso, simplemente bastaría con introducirle los datos de entrada necesarios ($\dot{x}$, $\dot{y}$ y $\dot{\varphi}$) para obtener las salidas esperadas ($\dot{\theta}$ y $\omega$).\\

Para garantizar el funcionamiento del modelo inverso, se va a realizar el tercer apartado del proyecto, donde se pide obtener las señales de control necesarias para que el robot realice una trayectoria parabólica, la cual va a venir dada por la expresión:

\begin{center}
 $y=-\dfrac{x(x-A)}{D}$
\end{center}
donde, \textit{X} e \textit{Y} son las coordenadas cartesianas de la posición del centro del robot, $A$ una constante que determinará el valor máximo en $x$ que alcanzará la parábola y $D$ otra constante que determinará el valor máximo en $y$ que alcanzará la parábola.\\

	\subsubsection{Esquema de simulación del modelo inverso obtenido}
Para explicar como se ha llevado a cabo el proceso de obtención de los resultados, se va a hacer uso del montaje en Simulink utilizado en esta parte:
\begin{figure}[h!]
	\centering
	\includegraphics[width=.7\textwidth]{simulink_MCI_1}
	\caption{Esquema global}
\end{figure}

%Dado el esquema global utilizado para la simulación del experimento, se va a empezar a explicar en orden de ejecución, por lo que se %comenzará por el bloque de "Trayectoria Parabólica":

%\begin{figure}[h!]
%	\centering
%	\includegraphics[width=1\textwidth]{simulink_MCI_2}
%	\caption{Bloque de Trayectoria Parabólica}
%\end{figure}

Como se pudo observar, las entradas a este bloque son las 2 constantes (\textit{A} y \textit{D}) de la parábola y el tiempo de simulación. Las dos primeras son utilizadas para la formulación de la parábola en sí y la tercera para la definición de \textit{X} que crecerá linealmente pero a una escala 5 veces más pequeña que el tiempo de simulación.\\

Para trazar la trayectoria se ha implementado la siguiente función en matlab, la cuál se implementará en Simulink cómo de costumbre. La salidas de dicha función serán las que se ven en el esquema de Simulink mostrado anteriormente.

\lstinputlisting[caption = {Implementación trayectoria parabolica}]{tray_parab.m}


%A la derecha del multiplexor se encuentra una primera función que determinará el valor de \textit{Y}, es decir, es la función de la %parábola, tal y como se había descrito anteriormente.\\
%Un poco más abajo se encuentra otra función que en realidad la derivada de la primera, puesto que se busca calcular la tangente a la %parábola en cada instante para así poder obtener la pendiente de dicha recta, realizar la arcotangente y hallar el ángulo que conforma %con el eje X, que coincidirá con la definición del ángulo $\varphi$.\\

Una vez se han definido los puntos de la trayectoria que ha de seguir el robot y con qué orientación ha de hacerlo, simplemente hay que pasar dichos datos al bloque donde se encuentra el modelo cinemático inverso:

\begin{figure}[h!]
	\centering
	\includegraphics[width=.7\textwidth]{simulink_MCI_3}
	\caption{Bloque dónde se implementa la cinemática inversa del robot}
\end{figure}

Como se puede observar, lo primero que se debe hacer es derivar cada una de las entradas respecto al tiempo, puesto que el Jacobiano inverso, como antes lo hacía el directo, considera relaciones entre velocidades. Cabe destacar que, derivar computacionalmente no es una buena técnica, debido a que añade una componente elevada de error, sin embargo, en éste caso, dicha componente es asumible. Si en alguna otra ocasión fuese posible, sería mucho mas conveniente integrar una velocidad para conocer la posición que derivar una posición para conocer la velocidad.\\

\newpage
Una vez hecho eso, se introducen los valores en el bloque que contiene a la función que ejecuta la cinemática inversa, cuyo código se muestra a continuación:

\lstinputlisting[caption = {Modelo cinemático inverso del robot sincrono}]{MCI_movil.m}

Se observa que simplemente se realiza la multiplicación matricial para obtener las variables de actuación.\\

Por último, antes de volver al esquema global, se saturan los valores de estas salidas con las mismas saturaciones que se habían determinado realistas en la cinemática directa.\\
Para terminar, en el esquema global, se coloca de nuevo el bloque de la cinemática directa para comprobar, con las variables de actuación obtenidas con el modelo inverso, se obtiene la misma trayectoria que se ha diseñado.\\

\newpage
\subsubsection{Experimentos realizados al modelo inverso para su verificación}
Con el montaje en Simulink ya creado, lo único que falta es lanzar un script que asigne valores a las incógnitas de la simulación ($A$ y $D$) y represente los datos:
	% AQUI VA EL CODIGO DE PRUEBAS MCI -> METIDO EN UN ANEXO

Se debe tener en cuenta siempre que en la posición inicial hay que determinar la orientación inicial que debe tener el robot, lo cual se podrá obtener fácilmente como \textit{atan($\frac{A}{D}$)}. Esto debe ser así porque, en caso contrario, al estar el robot en reposo con $\varphi$ nulo, al principio de la trayectoria el valor de velocidad de rotación saturará intentando conseguir dicha orientación y la trayectoria no será la misma porque el sistema, con dicha saturación, no será capaz de realizarla en un tiempo tan pequeño. Así, para unos valores de $A=3$ y $D=10$, obtenemos:

\begin{figure}[h!]
	\centering
	\includegraphics[width=.8\textwidth]{parab_1}
	\caption{Comparativa entre la trayectoria pedida y la obtenida}
\end{figure}


Como se puede observar, en la gráfica comparativa anterior entre la trayectoria creada por funciones y la obtenida a partir de los valores de las variables de actuación sacadas del modelo cinemático inverso, los resultados son prácticamente iguales, por lo que se puede decir que el modelo inverso es aceptable.\\

Aparte, se van a mostrar las gráficas de los valores de las variables de actuación obtenidas con la cinemática inversa, así como el valor de la variable $\varphi$:
\begin{figure}[h!]
	\centering
	\includegraphics[width=.8\textwidth]{parab_2}
	\caption{Valores de las variables de actuación}
\end{figure}

\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_3}
	\caption{Valor de la orientación a lo largo de la trayectoria}
\end{figure}

Como se observa, en ambas velocidades no se produce saturación alguna, ya que están por debajo y por encima de sus respectivos valores de saturación. Además, con la gráfica de la orientación, se puede observar como justo a la mitad de la trayectoria, la misma es 0, ya que el robot se encuentra en paralelo al eje X en dicho momento.\\

Cabe añadir que es lo que pasaría si las variables de actuación saturasen, ya que no podrían realizar la misma trayectoria. Para ello se van a mostrar dos experimentos distintos. El primero de ellos se basa en bajar la saturación de $\dot{\theta}$ a la mitad, es decir, a $\pm$0.375:

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_4}
	\caption{Comparativa de trayectorias con $\dot{\theta}$ saturada}
\end{figure}
\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_5}
	\caption{Valores de variables de actuación con saturación en $\dot{\theta}$}
\end{figure}

Como se puede observar, la trayectoria real que alcanza el robot se reduce tanto en \textit{X} como en \textit{Y}. Esto es lógico desde el punto de vista de la cinemática, puesto que al no poder alcanzar la velocidad necesaria, no llegará a ninguno de los valores objetivos en las coordenadas cartesianas. En la figura anterior se puede ver como $\dot{\theta}$ satura mientras que $\omega$ no.\\

Ahora se probará a saturar la velocidad de rotación, reduciendo el límite original a una décima parte, obteniendo una nueva saturación de $\pm$0.02618:
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_6}
	\caption{Comparativa de trayectorias con $\omega$ saturada}
\end{figure}

\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_7}
	\caption{Valores de variables de actuación con saturación en $\omega$}
\end{figure}
Aquí, como también era de esperar, el robot no puede seguir la trayectoria especificada, aunque esta vez lo hace de forma distinta. Esto se debe a que tiene la velocidad de desplazamiento necesaria para alcanzar los puntos objetivos pero no la capacidad de rotar lo suficientemente rápido como para seguirlos y por ello, se sobrepasa de sus objetivos. En la figura 17 se observa la saturación en $\omega$.\\
El efecto que se produce al haber saturaciones en ambas actuaciones es una combinación de ambos resultados, es decir, el "no poder girar a tiempo" y el "no avanzar lo suficientemente rápido":
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_8}
	\caption{Comparativa de trayectorias con $\omega$ y $\dot{\theta}$ saturadas}
\end{figure}
\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{parab_9}
	\caption{Valores de variables de actuación con saturación en $\omega$ y $\dot{\theta}$}
\end{figure}

\newpage
\section{Control dinámico}
En lo que a la implementación de un algoritmo de control dinámico sobre el robot concierne, en primer lugar será necesario compltear el modelo añadiendo la dinámica de los actuadores.\\
Los actuadores del robot serán 3 motores de corriente continua, cuya función de transferencia que relaciona la entrada de tensión del motor con la salida en velocidad del mismo se define del siguiente modo:
\begin{equation}
	G(s)=\frac{v(s)}{u(s)}=\frac{K}{\tau s+1}
\end{equation}
Será necesario definir el valor de la ganancia de la función de transferencia y la constante de tiempo, los cuales se obtendrán experimentalmente y unificarán toda la dinámica del motor, es decir,momento de inercia del motor, coeficiente de fricción viscosa, constante de fuerza contra-electromotriz, etcétera.
\subsection{Implementación de diversos algoritmos de control}
	\subsubsection{Control a un punto}
	En este apartado se va a realizar el control de movimiento a un punto, interesando únicamente que el robot consiga alcanzar dicho objetivo, sin importar orientación y sin restricciones temporales.\\
	
	Para comenzar se hablará de la estrategia de control, la cual se basa en la teoría dada en clase con el uso de la ley de control proporcional:\\
	
	\begin{equation}
	v^*=K_v\sqrt{((x^*-x)^2+(y^*-y)^2)}	
	\end{equation}
	\begin{equation}
	\omega=K_h(\varphi^*-\varphi)
	\end{equation}
	
	donde $v$ es la velocidad lineal de desplazamiento en control, $K_v$ la constante de proporción que se deberá ajustar, $(x^*,y^*)$ el punto objetivo, $(x,y)$ el punto actual, $\omega$ el valor de velocidad angular de orientación en control, $K_h$ la constante de proporción para la velocidad de rotación que deberá ser siempre mayor que 1, $\varphi^*$ el ángulo objetivo en cada momento de la trayectoria para llegar al punto objetivo que se calcula como $\varphi^*=atan(\dfrac{y^*-y}{x^*-x})$ y $\varphi$ el ángulo de rotación actual.\\
	
	Dicha ley de control proporcional se ha implementado en una función de MATLAB a la que se le introducen las referencias de posición así como la realimentación de posiciones y orientación actuales, y se le saca las velocidades de desplazamiento y rotación que han de ser aplicadas al robot.\\
	
	Para la comprobación de este controlador se ha realizado un script de pruebas donde se pueden introducir los valores de $(x^*,y^*)$ y decidir si el robot, en la posición inicial que parte de (0,0), va a estar orientado hacia el punto objetivo o no, en cuyo caso la variable $\varphi$ valdrá también 0.\\
	Se mostrarán entonces, a continuación, los resultados obtenidos con la introducción de distintos puntos objetivos:\\
	\newpage
	\begin{itemize}
		\item \textbf{Punto objetivo (0,5) sin preorientación}
		\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{control_punto_1}
		\caption{Trayectoria realizada en control de un punto}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_punto_1_2}
			\caption{Velocidades a lo largo del tiempo de la trayectoria (arriba $\dot{\theta}$ y abajo $\omega$)}
		\end{figure}
		\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{control_punto_1_3}
		\caption{Posiciones del robot a lo largo de la trayectoria respecto al tiempo}
		\end{figure}
\newpage
		Como se puede observar, al no encontrarse el robot orientado hacia el punto objetivo en la posición inicial, para llegar al destino deberá realizar un giro aproximadamente 180 grados.\\
		Se puede observar también como al principio no es capaz de girar rápidamente hacia el objetivo, y esto se debe a la saturación que se ha establecido en la misma pues, como se muestra en la gráfica de velocidades, los primeros 6 segundos, se encuentra girando al máximo de velocidad. Esto se encuentra también en la gráfica de la posición X frente al tiempo, donde en el segundo 6 el robot empieza a volver al valor de $x^*$ solicitado una vez el robot ya ha conseguido orientarse y no hace falta que le aplique la máxima velocidad de rotación.\\
		También se puede concluir que el robot se queda en el punto objetivo una vez alcanzado puesto que en las gráficas se puede observar que llega a éste antes de que termine la simulación.
		
		\item \textbf{Punto objetivo (0,5) con preorientación}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_punto_2}
			\caption{Trayectoria realizada en control de un punto}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_punto_2_2}
			\caption{Posiciones del robot a lo largo de la trayectoria respecto al tiempo}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_punto_2_3}
			\caption{Velocidades a lo largo del tiempo de la trayectoria (arriba $\dot{\theta}$ y abajo $\omega$)}
		\end{figure}
	
	Este caso es igual que el anterior pero habiendo realizado preorientación en la posición inicial hacia el punto objetivo. Es por esto que el robot únicamente deberá seguir una línea recta, puesto que ya se encuentra orientado y únicamente hará falta que actúe la variable de velocidad de desplazamiento $\dot{\theta}$.
	\end{itemize}

	Se pueden realizar más experimentos pero éstos no dan más información, puesto lo único que hay que tener en cuenta al darle dicho punto es que se ha dejado un tiempo de simulación suficiente para que el robot pueda llegar al objetivo y que con las velocidades máximas implementadas es capaz de hacerlo en dicho tiempo.

	
	
	\subsubsection{Control a una línea}
	En este apartado se va a estudiar el control de seguimiento de una línea por parte del robot. Para ello debemos conocer en primer lugar la recta que se desea seguir, la cual vendrá descrita como $ax+by+c=0$\\
	Utilizando entonces la ley de control proporcional para el ángulo de orientación, se deberá implementar el control descrito a continuación:
	\begin{equation}
	\omega=-K_dd+K_h(\varphi^*-\varphi)
	\end{equation}
	donde $K_d$ es la constante de proporción para el control de la distancia a la que se encuentra el robot de la línea a seguir, $K_h$ la constante de proporción para el control de la orientación respecto a la línea, $\varphi^*$ y $\varphi$ los ángulos de orientación de referencia, calculada como $\varphi^*=atan(\frac{-a}{b})$, y actual, y $d$ la distancia del robot a la línea definida como $d=\frac{(a,b,c)\cdot(x,y,1)}{\sqrt{a^2+b^2}}$.\\
	Como se puede apreciar en este tipo de control no se controla la velocidad de desplazamiento pues no es necesario, por lo que se le asigna un valor constante de 0.5 rad/s.\\
	
	Una vez descrito el funcionamiento del control, implementado en una función de MATLAB donde se han puesto la restricciones de que las líneas siempre avanzarán en X positivo y que no podrán ser verticales para facilitarla implementación del mismo.\\
	Una vez tenidas en cuenta dichas restricciones, se puede pasar a realizar experimentos que determinen la fiabilidad del control:
	
	\begin{itemize}
		\item \textbf{Recta a seguir con A=2, B=5 y C=3}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_linea_1}
			\caption{Trayectoria realizada en control de seguimiento de línea}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics[width=1\textwidth]{control_linea_1_2}
			\caption{Velocidades de actuación a lo largo del tiempo de la trayectoria (arriba $\dot{\theta}$ y abajo $\omega$)}
		\end{figure}
	Se puede observar como el robot se dirige hacia la recta de referencia de la forma más rápida que es capaz con las saturaciones pertinentes. Se puede comprobar esto también observando las gráficas de las velocidades de actuación, ya que la velocidad de rotación comienza saturada y a los 4 segundos cambia de signo para poder comenzar el seguimiento de la recta de forma suave. El robot no comienza a seguir la trayectoria por el principio de la misma debido a que el punto de ésta que ha de seguir va cambiando a lo largo de la simulación.\\
	
	\item \textbf{Recta a seguir con A=0, B=1 y C=-2}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{control_linea_2}
		\caption{Trayectoria realizada en control de seguimiento de línea}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{control_linea_2_2}
		\caption{Velocidades de actuación a lo largo del tiempo de la trayectoria (arriba $\dot{\theta}$ y abajo $\omega$)}
	\end{figure}
	En este caso se ha optado por hacer el experimento con una linea horizontal. Como se observa el resultado es muy parecido al del experimento anterior, aunque en este caso una vez alcanzada la recta el robot sobrepasa la misma y debe volver a ella. Esto se debe a que el robot llega a dicha recta de referencia con una orientación de casi 90 grados con respecto a la que tiene la trayectoria de 0 grados y, como las variables de actuación se encuentran saturadas, el robot intenta obtener esa orientación pero tarda más de lo debido.
	\end{itemize}
	\subsubsection{Control a una trayectoria}
	En este apartado se va a realizar el control de una trayectoria, que, a grandes rasgos, es muy semejante al control de un punto, pues se puede interpretar como una sucesión de puntos en el tiempo.\\
	En este caso se puede indicar también la distancia $d^*$ a la que se desea que el robot realice el seguimiento de la trayectoria, es decir, que la realice igual pero de forma paralela. Para todo esto se necesita implementar la ley de control proporcional más integral para la velocidad y la ley proporcional para la orientación.\\
	De esta forma, primero se calcula el error en posición como
	\begin{equation}
	e=\sqrt{(x^*-x)^2+(y^*-y)^2}-d^*,
	\end{equation}
	y, acto seguido, se realiza el control proporcional e integral para la velocidad de desplazamiento tal que
	\begin{equation}
	v^*=K_ve+K_i\int{edt}
	\end{equation}
	Realizado el control de la velocidad de desplazamiento, se puede controlar la orientación exactamente de la misma forma que en el control a un punto:
	\begin{equation}
	\omega=K_h(\varphi^*-\varphi),
	\end{equation}
	con $\varphi^*=atan(\frac{y^*-y}{x^*-x})$.\\
	
	Una vez vista la teoría que compone al control del seguimiento de una trayectoria se va a proceder a su implementación, para lo cual se ha optado por realizarla en tiempo discreto, necesitando variaciones en el esquema de simulación como el muestreo de señales y tiempo para el trabajo en la misma, así como cambios en el código de control como la implementación del efecto integral calculado como el área que abarca la gráfica del error en un período de muestreo. Tanto esquema como códigos pueden ser visualizados en el apartado de anexos.\\
	
	Una vez implementado todo, se va a comprobar el funcionamiento del control con la realización de dos trayectorias distintas. La primera de ellas se basa en una función a trozos compuesta de 4 tramos correspondientes a rectas de diferente pendiente; y la segunda consiste en la creación de una trayectoria a través de un interpolador con spline dados 3 puntos a seguir.\\
	A continuación se mostrarán los resultados obtenidos para cada experimento:
	
	\begin{itemize}
		\item \textbf{Trayectoria lineal}
		
	\end{itemize}
	
	
	\subsubsection{Control a una postura}

\newpage

\subsection{Ley de control \textit{Persecución pura}}
Por ultimo, se implementara una ley de control comun en robotica movil, la cual se define como persecucion pura o \textit{Pure Pursuit}. Con esta tecnica se busca un seguimiento de un camino explicito, el cual se encuentra determinado por un generador de trayectorias.\\
Esta ley de control se ha optado por implementarla, en lugar de buscando la minima distancia entre la recta de la trayectoria y la posicion del robot, realizando un control de postura mezclado con un seguimiento de trayectoria. \\
Este control de la postura del robot tendra acentuada la ganancia que minimiza el angulo que forma la recta que une la posicion actual del robot con el punto que se obtiene del generador de trayectorias.\\
En la figura que se muestra a continuacion, la cual contiene la misma notacion que el control a una postura, dicho angulo sera $\alpha$:

\begin{figure}[h!]
   \centering
   \includegraphics[width=0.4\textwidth]{postura}
   \caption{Representacion del angulo y la distancia calculados}
\end{figure}

Por tanto, matematicamente se calculara como:
\begin{center}
$\rho=\sqrt{(y^*-y)^2+(x^*-x)^2}$ \\
$\alpha=atan\Big(\dfrac{y^*-y}{x^*-x}\Big)-\varphi$ \\
$\beta=-\varphi-\alpha$
\end{center}

Las leyes de control que se implementaran a los motores del robot son:
\begin{center}
$v=\frac{K_{\rho}\rho}{R}$ \\
$\omega=K_{\alpha}\alpha + K_{\beta}\beta$
\end{center}

Para definir los parametros de los controladores, sera necesario asegurarse de un criterio de signos que asegure la estabilidad del sistema en bucle cerrado. Se debe cumplir que: $K_{\rho}>0$,$K_{\beta}<0$ y que $\Big(K_{\alpha}-K_{\rho}\Big)>0$.\\
Por lo tanto, los parametros que se implementaran en los controladores son:
\begin{center}
$K_{\rho}=2.2$\\
$K_{\beta}=-0.1$\\
$K_{\alpha}=K_{\beta}+5.8$
\end{center}
Como se puede observar, se ha acentuado el valor de la ganancia asociada al angulo $\alpha$. \\

Para verificar el correcto funcionamiento de este controlador, se hara que siga la siguiente senoide:
\begin{center}
$x=At=0.2t$\\
$y=Bsin(\omega t)=1.2*sin(0.2t)$
\end{center}

A continuacion, se mostraran las graficas que muestran los resultados de dicho experimento


Con los valores asignados a los controladores y trayectoria propuesta se presentan los siguientes
	resultados de simulación.\\ 



\newpage	
	\begin{itemize}
		
		\item Resultados Persecución de Trayectoria::
	\begin{center}
		$A=0.2$    \hspace{0.2cm}   
		$B=1.2$    \hspace{0.2cm} 
		$w=0.2$ \\
	\end{center}

	En primer lugar, se muestra la superposicion de la referencia dinamica y de la posicion del 
	robot; además de los errores asociados a cada porsicion cartesiana.\\


	\begin{figure}[h!]
		\centering
		\includegraphics[width=1\textwidth]{PurePursuitSeguimiento_Error}
		\caption{Referencia Vs Seguimiento}
	\end{figure}

	Como se observa, en el inicio de las trayectoria, se presenta una variacion en mayor frecuencia
	en la postura del robot; al estabilizar la velocidad del seguimiento de la trayectoria,
	el robot continua la tecnica de seguimiento de persecucion pura de la trayectoria de forma estable.\\

	Sobre el error, vemos que tenemos un error mantenido  en la posicion \textit{X}, lo que 
	nos indica un retraso inebitable, pero lo suficientemente pequeño; y por el el lado del error 
	en \textit{Y}, se observa un error oscilante, que indica que no se estan alcanzando los valores de la referencia
	con total exactitud.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.8\textwidth]{PurePursuitValoresEntrada}
		\caption{Señales de Control}
	\end{figure}

	Esta siguiente grafica, muestra las señales de control generadas para la trayectoria exigida
	a lo largo del tiempo de simulación, en esta se puede comprobrar el trabajo del control en la 
	dirección de referencia, cuya llegada al regimen permantente coincide  con el cese del cambio 
	brusco en la orientación del robot; y la referencia lineal en este momento obtiene una señal periodica, 
	tal y como se podria suponer de una trayectoria de este estilo.\\

	\end{itemize}



\begin{itemize}
	\item Resultados Persecución de Trayectoria:
	\begin{center}
		$A=0.2$    \hspace{0.2cm}   
		$B=1.2$    \hspace{0.2cm} 
		$w=0.08$ \\
	\end{center}

	La disminucion de la amplitud mejora en gran medida al seguimiento de la trayectoria, para nuestro
	modelo de robot movil.\\
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.9\textwidth]{PurePursuitSeguimientoFlama_Error}
		\caption{Referencia Vs Seguimiento}
	\end{figure}

	Como se puede observar, comprobamos una linealidad en el cambio de de la orientacion y un seguimiento
	limpio de la la trayectoria, aun asi, y como se comentó anteriormete, existe un retraso asociado a la 
	velocidad del robot asociada costante en ambos experimentos.

	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\textwidth]{PurePursuitValoresEntradaFlama}
		\caption{Señales de Control}
	\end{figure}

	Como se pudiese esperar, la variacion de la entrada Señal de \textit{Velocidad Lineal} ocupada del control
	del la velocidad de recorer un seno matematico se equipare con la cosenoidal de esta; a pesar de ello,
	la variacion de esta es pequieza, lo que puede asumirse a nivel dinamico.\\
	En un orden de magnitud menor, se encuentra la variacion de la señal de control de la \textit{Velocidad de Dirección}
	, de forma constante tras un inicio sobreoscilado debido a una posicion de origen no alineada con la trayectoria.\\



	\end{itemize}





%\section{Anexos y conclusiones}
%\subsection{Codigos de programacion}
%\subsubsection{Pruebas del modelo cinematico directo}
%\lstinputlisting[caption = {caption caption caption}]{pruebasMCD.m}
%\newpage
%\subsubsection{Pruebas del modelo cinematico inverso}
%\lstinputlisting[caption = {caption caption caption}]{pruebasMCI.m}

\end{document}
